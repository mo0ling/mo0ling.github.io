<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java并发 | 墨凌的博客</title><meta name="author" content="墨凌"><meta name="copyright" content="墨凌"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="1. 请说一下CAS原理？:star::star::star::star::two:比较并且设置&#x2F;交换（CompareAndSet），乐观锁的一种实现；写操作包括三步，第一步先读，第二步运算，第三步写回去；那么乐观锁是第一步读的时候记录这个内存值，写回到共享变量的时候判断当初读的期望值是否和内存上的值一致。如果一致表示没有别的线程修改，否则中途发送了修改，需要自旋重新CAS写入。弊端是A">
<meta property="og:type" content="article">
<meta property="og:title" content="Java并发">
<meta property="og:url" content="https://mo0ling.github.io/posts/918971b1.html">
<meta property="og:site_name" content="墨凌的博客">
<meta property="og:description" content="1. 请说一下CAS原理？:star::star::star::star::two:比较并且设置&#x2F;交换（CompareAndSet），乐观锁的一种实现；写操作包括三步，第一步先读，第二步运算，第三步写回去；那么乐观锁是第一步读的时候记录这个内存值，写回到共享变量的时候判断当初读的期望值是否和内存上的值一致。如果一致表示没有别的线程修改，否则中途发送了修改，需要自旋重新CAS写入。弊端是A">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://source.fomal.cc/img/default_cover_14.webp">
<meta property="article:published_time" content="2023-11-12T07:13:53.000Z">
<meta property="article:modified_time" content="2023-11-12T01:50:32.010Z">
<meta property="article:author" content="墨凌">
<meta property="article:tag" content="java 开发语言 基础">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://source.fomal.cc/img/default_cover_14.webp"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://mo0ling.github.io/posts/918971b1.html"><link rel="preconnect" href="//cdnjs.cloudflare.com"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/node-snackbar/0.1.16/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.24/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: {"appId":"OJQXVBAQG1","apiKey":"5eaa2e0c3fca2242ca816a7a80f71636","indexName":"hexoblog","hits":{"per_page":6},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"已经过期","messageNext":"天, 这篇文章需要淘汰。"},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体中文","cht_to_chs":"你已切换为简体中文","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"var(--theme-color)","bgDark":"#191919","position":"top-right"},
  infinitegrid: {
    js: 'https://cdnjs.cloudflare.com/ajax/libs/egjs-infinitegrid/4.10.1/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java并发',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-11-12 09:50:32'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/fonts/font.css"><link rel="stylesheet" href="https://cdn1.tianli0.top/npm/element-ui@2.15.6/packages/theme-chalk/lib/index.css"><style id="defineBg"></style><style id="menu_shadow"></style><svg aria-hidden="true" style="position:absolute; overflow:hidden; width:0; height:0"><symbol id="icon-sun" viewBox="0 0 1024 1024"><path d="M960 512l-128 128v192h-192l-128 128-128-128H192v-192l-128-128 128-128V192h192l128-128 128 128h192v192z" fill="#FFD878" p-id="8420"></path><path d="M736 512a224 224 0 1 0-448 0 224 224 0 1 0 448 0z" fill="#FFE4A9" p-id="8421"></path><path d="M512 109.248L626.752 224H800v173.248L914.752 512 800 626.752V800h-173.248L512 914.752 397.248 800H224v-173.248L109.248 512 224 397.248V224h173.248L512 109.248M512 64l-128 128H192v192l-128 128 128 128v192h192l128 128 128-128h192v-192l128-128-128-128V192h-192l-128-128z" fill="#4D5152" p-id="8422"></path><path d="M512 320c105.888 0 192 86.112 192 192s-86.112 192-192 192-192-86.112-192-192 86.112-192 192-192m0-32a224 224 0 1 0 0 448 224 224 0 0 0 0-448z" fill="#4D5152" p-id="8423"></path></symbol><symbol id="icon-moon" viewBox="0 0 1024 1024"><path d="M611.370667 167.082667a445.013333 445.013333 0 0 1-38.4 161.834666 477.824 477.824 0 0 1-244.736 244.394667 445.141333 445.141333 0 0 1-161.109334 38.058667 85.077333 85.077333 0 0 0-65.066666 135.722666A462.08 462.08 0 1 0 747.093333 102.058667a85.077333 85.077333 0 0 0-135.722666 65.024z" fill="#FFB531" p-id="11345"></path><path d="M329.728 274.133333l35.157333-35.157333a21.333333 21.333333 0 1 0-30.165333-30.165333l-35.157333 35.157333-35.114667-35.157333a21.333333 21.333333 0 0 0-30.165333 30.165333l35.114666 35.157333-35.114666 35.157334a21.333333 21.333333 0 1 0 30.165333 30.165333l35.114667-35.157333 35.157333 35.157333a21.333333 21.333333 0 1 0 30.165333-30.165333z" fill="#030835" p-id="11346"></path></symbol></svg><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-categories-card@1.0.0/lib/categorybar.css"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.css" /><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.0.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (true) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/assets/tx.jpg" onerror="onerror=null;src='/assets/r1.jpg'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">131</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">32</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw icon-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw icon--article"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw icon-wangye"></i><span> 网站</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/site/census/"><i class="fa-fw icon--tongjibiao"></i><span> 网站统计</span></a></li><li><a class="site-page child" href="/site/echarts/"><i class="fa-fw icon-shujutongji1"></i><span> 文章统计</span></a></li><li><a class="site-page child" href="/site/time/"><i class="fa-fw icon-xianxingshalou"></i><span> 旧时光</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw faa-tada"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://source.fomal.cc/img/default_cover_14.webp')"><nav id="nav"><span id="blog-info"><a href="/" title="墨凌的博客"><span class="site-name">墨凌的博客</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw icon-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw icon--article"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw icon-wangye"></i><span> 网站</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/site/census/"><i class="fa-fw icon--tongjibiao"></i><span> 网站统计</span></a></li><li><a class="site-page child" href="/site/echarts/"><i class="fa-fw icon-shujutongji1"></i><span> 文章统计</span></a></li><li><a class="site-page child" href="/site/time/"><i class="fa-fw icon-xianxingshalou"></i><span> 旧时光</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw faa-tada"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java并发</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-11-12T07:13:53.000Z" title="发表于 2023-11-12 15:13:53">2023-11-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-11-12T01:50:32.010Z" title="更新于 2023-11-12 09:50:32">2023-11-12</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/Java%E5%B9%B6%E5%8F%91/">Java并发</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">10.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>32分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java并发"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="1-请说一下CAS原理？-star-star-star-star-two"><a href="#1-请说一下CAS原理？-star-star-star-star-two" class="headerlink" title="1. 请说一下CAS原理？:star::star::star::star::two:"></a>1. 请说一下<code>CAS</code>原理？:star::star::star::star::two:</h3><p>比较并且设置&#x2F;交换（<code>CompareAndSet</code>），乐观锁的一种实现；写操作包括三步，第一步先读，第二步运算，第三步写回去；那么乐观锁是第一步读的时候记录这个内存值，写回到共享变量的时候判断当初读的期望值是否和内存上的值一致。如果一致表示没有别的线程修改，否则中途发送了修改，需要自旋重新<code>CAS</code>写入。弊端是<code>ABA</code>问题，无效自旋带来的开销太大，且只能保证一个共享变量的原子性。如果要保证多个变量原子性则使用<code>AtomicReference</code>类，多个共享变量合并成一个对象变量操作</p>
<p><strong>题评：</strong> 非常重要的知识点！<br>::: details 点击查看详细答案<br>待补充…<br>:::</p>
<h3 id="2-CAS中的ABA问题是什么？-star-star-star-two"><a href="#2-CAS中的ABA问题是什么？-star-star-star-two" class="headerlink" title="2. CAS中的ABA问题是什么？:star::star::star::two:"></a>2. <code>CAS</code>中的<code>ABA</code>问题是什么？:star::star::star::two:</h3><p><code>CAS</code>将期望值与内存原值判断的时候，如果判断相等其实不能说明内存原值没有人改过，其实很可能是别的线程将<code>A</code>改为<code>B</code>后又改回了<code>A</code>，发生了修改但是看起来好像没有。如何避免？ 使用版本号机制的乐观锁。</p>
<p><strong>题评：</strong> 无<br>::: details 点击查看详细答案<br>待补充…<br>:::</p>
<h3 id="3-讲一下JUC中的原子类？-star-star-star-two"><a href="#3-讲一下JUC中的原子类？-star-star-star-two" class="headerlink" title="3. 讲一下JUC中的原子类？:star::star::star::two:"></a>3. 讲一下<code>JUC</code>中的原子类？:star::star::star::two:</h3><ul>
<li>基本原子类：<code>AtomicInteger</code>、<code>AtomicLong</code>、<code>AtomicBoolean</code>。</li>
<li>数组原子类：<code>AtomicIntegerArray</code>，<code>AtomicReferenceArray</code>。</li>
<li>引用原子类：<code>AtomicReference</code><br>以上是通过<code>CAS</code>和<code>Volatile</code>结合的方式实现的，<code>CAS</code>保证原子性，<code>Volatile</code>保证线程可见与避免指令重排。大大提高了并发的效率。</li>
</ul>
<p><strong>题评：</strong> 无<br>::: details 点击查看详细答案<br>待补充…<br>:::</p>
<h3 id="4-LongAdder-的原理了解吗？-star-star-three"><a href="#4-LongAdder-的原理了解吗？-star-star-three" class="headerlink" title="4. LongAdder 的原理了解吗？:star::star::three:"></a>4. <code>LongAdder</code> 的原理了解吗？:star::star::three:</h3><p>在争用激烈的场景下，会导致大量的<code>CAS</code>空自旋。可以使用<code>LongAdder</code>替代<code>AtomicInteger</code>。以空间换时间，<code>LongAdder</code>核心思想就是热点分离，与<code>ConcurrentHashMap</code>的设计思想类似：将<code>value</code>值分离成一个数组（<code>base</code>+<code>cell</code>…），当多线程访问时，通过<code>Hash</code>算法将线程映射到数组的一个元素进行操作；而获取最终的<code>value</code>结果时，则将数组的元素求和。相当于分段乐观锁！</p>
<p><strong>题评：</strong> 不怎么常考，但是<code>JUC</code>了解的话这个是必须知道的！<br>::: details 点击查看详细答案<br>待补充…<br>:::</p>
<h3 id="5-为什么代码会指令重排？-star-star-star-star-four"><a href="#5-为什么代码会指令重排？-star-star-star-star-four" class="headerlink" title="5. 为什么代码会指令重排？:star::star::star::star::four:"></a>5. 为什么代码会指令重排？:star::star::star::star::four:</h3><ul>
<li>为了提高执行速度会进行指令重排，但是需要满足以下两点：存在依赖关系的不允许重排；重排不影响单线程执行结果，但是会改变多线程的执行语义。</li>
<li>例如：<code>new</code> 一个对象，一般是三步，第一步申请堆内存空间，第二步初始化内存空间，第三步引用指向堆内存空间；但是很可能第二步和第三步会交换，指令重排。而在多线程环境下，判断一个对象是否不为空时，往往第二步还没执行完，但三步就判断不为空。而加了<code>Volatile</code>并不止禁止指令重排，而是在三步写操作未完成之前不允许判断为<code>null</code>时候的读。因此，最后判断时一定是完成了三步操作。</li>
</ul>
<p><strong>题评：</strong> 无<br>::: details 点击查看详细答案<br>待补充…<br>:::</p>
<h3 id="6-讲解一下-Volatile关键字的作用？-star-star-star-star-four"><a href="#6-讲解一下-Volatile关键字的作用？-star-star-star-star-four" class="headerlink" title="6. 讲解一下 Volatile关键字的作用？:star::star::star::star::four:"></a>6. 讲解一下 <code>Volatile</code>关键字的作用？:star::star::star::star::four:</h3><ul>
<li>保证线程可见性：线程修改变量后立即从工作内存刷到主存上，当读的时候如果被<code>Volatile</code>修饰了就直接从主存读取最新值而不是工作内存。</li>
<li>防止指令重排，即保证写操作会发生在后续的读操作之前，例如<code>new</code> 对象，但是无法保证原子性。</li>
</ul>
<p><strong>题评：</strong> 禁止代码重排是通过指令屏蔽实现的：关键词：<code>ll</code>，<code>ls</code>，<code>ss</code>，<code>sl</code> 指令屏蔽，普通读写，<code>Volatile</code>读写，来保证指令的一个顺序性。这一块比较难记忆，一般不会问这么细！达到这里基本上可以了！<br>::: details 点击查看详细答案</p>
<ul>
<li>保证线程可见：在JMM模型中，内存分为主内存和3级缓存，每个线程访问共享变量时都会从主存中读取变量值然后暂存在L1缓存中，每次修改都是先在缓存上修改，在一定时间后刷新到主存，这样就存在数据不一致的情况。通过volatile修饰的变量，强制线程每次都从主存中读取最新的值然后修改后都立即刷回到主存。保证其他线程能够在修改的第一时间获取变量最新值。</li>
<li>保证指令重排：指令重排是为了避免CPU切换跨度太大导致效率低下；但是在多线程并发情况下，指令重排会导致线程安全性问题。因此volatile通过四个指令屏蔽LL、LS、SL，SS来保证被Volatile修饰的变量前后是否可以普通读、普通写、volatile读、volatile写。例如，在单例模式下创建单例对象的时候需要volatile修饰单例对象，因为创建对象时会指令重排，先是申请内存，然后引用指向内存，然后创建对象。使用volatile就能保证只有三条原子语句都执行完了之后才能读到对象判断是否为null。<br>:::</li>
</ul>
<h3 id="7-Java中可以保证数组的可见性吗？-star-star-star-three"><a href="#7-Java中可以保证数组的可见性吗？-star-star-star-three" class="headerlink" title="7. Java中可以保证数组的可见性吗？:star::star::star::three:"></a>7. <code>Java</code>中可以保证数组的可见性吗？:star::star::star::three:</h3><p>可以使用<code>Volatile</code>保证引用的可见性，即引用指向了其他数组是可见的，但是数组元素不会收到保护。</p>
<p><strong>题评：</strong> 无<br>::: details 点击查看详细答案<br>待补充…<br>:::</p>
<h3 id="8-volatile-能使得一个非原子操作变成原子操作吗？-star-star-star-three"><a href="#8-volatile-能使得一个非原子操作变成原子操作吗？-star-star-star-three" class="headerlink" title="8. volatile 能使得一个非原子操作变成原子操作吗？  :star::star::star::three:"></a>8. <code>volatile</code> 能使得一个非原子操作变成原子操作吗？  :star::star::star::three:</h3><p>不能，需要保证原子性可以加锁保证；但是修饰<code>Long</code>和<code>Double</code>可以保证原子性，与数据类型的位数有关，<code>64</code>位；</p>
<p><strong>题评：</strong> 无<br>::: details 点击查看详细答案<br>待补充…<br>:::</p>
<h3 id="9-在哪里使用过volatile修饰符？-star-star-star-star-three"><a href="#9-在哪里使用过volatile修饰符？-star-star-star-star-three" class="headerlink" title="9. 在哪里使用过volatile修饰符？:star::star::star::star::three:"></a>9. 在哪里使用过<code>volatile</code>修饰符？:star::star::star::star::three:</h3><p>单例模式，给<code>instance</code>的声明加上<code>volatile</code>关键字 。<code>volatile</code>阻止的不是<code>singleton</code> &#x3D; <code>newSingleton()</code>这句话内部<code>[1</code> <code>2</code>  <code>3]</code>的指令重排。保证了在一个写操作（<code>[1</code>  <code>3</code>  <code>2]</code>）完成之前，不会调用读操作（<code>if</code> <code>(instance</code> &#x3D;&#x3D; <code>null)</code>  。</p>
<p><strong>题评：</strong> 无<br>::: details 点击查看详细答案<br>待补充…<br>:::</p>
<h3 id="10-synchronized-和-volatile-的区别是什么？-star-star-star-star-star-three"><a href="#10-synchronized-和-volatile-的区别是什么？-star-star-star-star-star-three" class="headerlink" title="10. synchronized 和 volatile 的区别是什么？ :star::star::star::star::star::three:"></a>10. <code>synchronized</code> 和 <code>volatile</code> 的区别是什么？ :star::star::star::star::star::three:</h3><p>两个的作用完全不一样，<code>synchronized</code> 加锁保证原子性，修饰代码块和方法；<code>volatile</code> 只能修饰变量，保证可见性与避免指令重排</p>
<p><strong>题评：</strong> 无<br>::: details 点击查看详细答案<br>待补充…<br>:::</p>
<h3 id="11-什么是不可变对象-Immutable-Objects-？-star-star-star-three"><a href="#11-什么是不可变对象-Immutable-Objects-？-star-star-star-three" class="headerlink" title="11. 什么是不可变对象(Immutable Objects)  ？:star::star::star::three:"></a>11. 什么是不可变对象<code>(Immutable</code> <code>Objects)</code>  ？:star::star::star::three:</h3><p>使用<code>final</code>修饰的对象，一旦被创建对象数据不能改变；是线程安全的；常见的不可变类：<code>String</code>，基本数据类型包装类。但是对这些基本数据对象+<code>1</code>实际上是创建了新的对象，而不是修改原对象，因此多线程环境下并不保证线程安全。</p>
<p><strong>题评：</strong> 无<br>::: details 点击查看详细答案<br>待补充…<br>:::</p>
<h3 id="12-Lock接口用过吗？与synchronized-有什么区别？-star-star-star-star-star-three"><a href="#12-Lock接口用过吗？与synchronized-有什么区别？-star-star-star-star-star-three" class="headerlink" title="12. Lock接口用过吗？与synchronized 有什么区别？:star::star::star::star::star::three:"></a>12. <code>Lock</code>接口用过吗？与<code>synchronized</code> 有什么区别？:star::star::star::star::star::three:</h3><p>自己没有实现过<code>Lock</code>，但是用过<code>ReenterLock</code>，它是<code>Lock</code>接口的实现类，那么他与<code>synchronized</code>的区别就是可以实现更加灵活地更具扩展性地定义自己的锁。例如<code>ReenterLock</code>提供了公平锁，可中断<code>lockInterruptibly</code> 、可轮询<code>tryLock</code>等功能。另外<code>synchronized</code>是<code>JVM</code>语法层的锁，而<code>ReenterLock</code>是<code>JDK</code>提供的<code>API</code>锁实现，使用<code>synchronized</code>如果出现异常会自动释放锁，而<code>Lock</code>接口需要在<code>finally</code>块中手动释放锁。</p>
<p><strong>题评：</strong> 无<br>::: details 点击查看详细答案</p>
<ul>
<li>相同点：阻塞式同步锁、可重入锁（’state++’）<br>不同点：</li>
<li>这两种方式最大区别就是对于’Synchronized’来说，它是’java’语言的关键字，是原生语法层面的互斥，需要’jvm’实现。而’ReentrantLock’它是JDK 1.5之后提供的API层面的互斥锁，需要’lock()’和’unlock()’方法配合’try&#x2F;finally’语句块来完成。  由于’ReentrantLock’是’java.util.concurrent’包下提供的一套互斥锁，相比’Synchronized’， ‘ReentrantLock’类提供了一些高级功能，主要有以下3项：<br>a. 等待可中断，持有锁的线程长期不释放的时候，正在等待的线程可以选择放弃等待，这相当于’Synchronized’来说可以避免出现死锁的情况。<br>b. 公平锁，多个线程等待同一个锁时，必须按照申请锁的时间顺序获得锁，’Synchronized’锁非公平锁，ReentrantLock默认的构造函数是创建的非公平锁，可以通过参数’true’设为公平锁，但公平锁表现的性能不是很好。<br>c. 可实现选择性通知 (锁绑定多个条件), 一个’ReentrantLock’对象可以同时绑定对个对象。’Condition’ 实例的 ‘signalAll()’ 方法 只会唤醒注册在该 ‘Condition’ 实例中的所有等待线程。 从而可用选择性通知唤醒而不是全部通知。’synchronized’ 依赖于 JVM 而 ‘ReentrantLock’ 依赖于 API<br>:::</li>
</ul>
<h3 id="13-什么是可重入锁？-star-star-star-star-three"><a href="#13-什么是可重入锁？-star-star-star-star-three" class="headerlink" title="13. 什么是可重入锁？:star::star::star::star::three:"></a>13. 什么是可重入锁？:star::star::star::star::three:</h3><p>对同一资源可以重复加锁，例如同一线程中，<code>A</code>、<code>B</code>方法都是同一把锁，<code>A</code>调用<code>B</code>方法就是可重入。<code>ReentrantLock</code>  和 <code>synchronized</code>  都是可重入锁。但是分布式锁中的<code>Reids</code>实现不是可重入，<code>Redission</code>是可重入。他们的实现是使用重入标记<code>state</code>表示，每次重入+<code>1</code>，释放-<code>1</code>，等于<code>0</code>表示释放了锁。</p>
<p><strong>题评：</strong> 无<br>::: details 点击查看详细答案<br>待补充…<br>:::</p>
<h3 id="14-ReadWriteLock-是什么，有ReentrantLock-为什么需要ReadWriteLock？-star-star-star-three"><a href="#14-ReadWriteLock-是什么，有ReentrantLock-为什么需要ReadWriteLock？-star-star-star-three" class="headerlink" title="14. ReadWriteLock 是什么，有ReentrantLock  为什么需要ReadWriteLock？:star::star::star::three:"></a>14. <code>ReadWriteLock</code> 是什么，有<code>ReentrantLock</code>  为什么需要<code>ReadWriteLock</code>？:star::star::star::three:</h3><p>读写锁，读读不会被锁，只有写参与了才加锁；因为多线程读数据并不会导致数据发生改变，没有必要加锁，加锁降低程序性能。<code>ReentrantReadWriteLock</code> 是 <code>ReadWriteLock</code> 接口的一个具体实现，实现了读写的分离，读锁是共享的，写锁是独占的，读和读之间不会互斥，读和写、写和读、写和写之间才会互斥，提升了读写的性能。</p>
<p><strong>题评：</strong> 无<br>::: details 点击查看详细答案<br>待补充…<br>:::</p>
<h3 id="15-有没有了解CLH队列？-star-star-four"><a href="#15-有没有了解CLH队列？-star-star-four" class="headerlink" title="15. 有没有了解CLH队列？:star::star::four:"></a>15. 有没有了解<code>CLH</code>队列？:star::star::four:</h3><p><code>CLH</code>队列是一个单向链表实现的<code>FIFO</code>队列，目的是<code>CLH</code>锁能大大减少<code>CAS</code>自旋带来的总线风暴。每个节点<code>Node</code>是包含三个重要属性，<code>locked</code>、<code>pre</code>、<code>thread</code>，首节点获取锁的节点，后面的都是排队等待锁的节点。当一个线程加入抢锁时，创建<code>Node</code>节点，通过<code>CAS</code>自旋加入到队列尾，指向前面的节点，通过普通自旋监控前面的节点是否释放了锁。如果前面节点释放了锁，则将指针指向<code>null</code>，然后将<code>locked</code>改为<code>false</code>。</p>
<p><strong>题评：</strong> 无<br>::: details 点击查看详细答案<br>待补充<br>:::</p>
<h3 id="16-AQS抽象同步队列是什么？-star-star-star-star-star-four"><a href="#16-AQS抽象同步队列是什么？-star-star-star-star-star-four" class="headerlink" title="16. AQS抽象同步队列是什么？:star::star::star::star::star::four:"></a>16. <code>AQS</code>抽象同步队列是什么？:star::star::star::star::star::four:</h3><p><code>AQS</code>是抽象同步队列，一个模板类用于构建自己的锁和同步容器，是<code>CLH</code>的一个变种。不同之处是采用双向链表，引入一个同步状态<code>vloatile</code> <code>int</code> <code>state</code>，其他和<code>CLH</code>原理类似。一开始<code>state</code>是<code>0</code>，新的线程来了调用<code>tryAcquire()</code> 独占锁，<code>state</code>+<code>1</code>，当其他线程也抢锁时，发现<code>state</code>不为<code>0</code>，于是构建<code>Node</code>通过<code>addwaiter()</code> <code>cas</code>入队。进入到队列的线程不会像<code>CLH</code>一样自旋判断前面的节点是否释放锁，而是进行了改进避免开销大，找到有效前驱（不是取消状态的<code>Node</code>），然后设置状态为<code>signal</code>，建立唤醒关系之后，进行自我阻塞。当头结点释放锁后，立即通知后驱节点唤醒，进行<code>CAS</code>抢锁，成为新的头节点。</p>
<p><strong>题评：</strong> 无<br>::: details 点击查看详细答案<br>待补充<br>:::</p>
<h3 id="17-ConcurrentHashMap原理-star-star-star-star-star-three"><a href="#17-ConcurrentHashMap原理-star-star-star-star-star-three" class="headerlink" title="17. ConcurrentHashMap原理:star::star::star::star::star::three:"></a>17. <code>ConcurrentHashMap</code>原理:star::star::star::star::star::three:</h3><ul>
<li><code>1</code>.<code>8</code>之前使用<code>segment</code>继承<code>ReentrantLock</code>充当锁（也称为并发度，默认<code>16</code>），<code>segment</code>维护哈希表的若干个同，每个桶由<code>HashEntry</code>构成的链表。</li>
<li><code>1</code>.<code>8</code>之后，抛弃了<code>Segment</code>分段锁，而采用 <code>CAS</code> + <code>synchronized</code> 来保证并发安全性。</li>
</ul>
<p><strong>题评：</strong> 无<br>::: details 点击查看详细答案<br>待补充<br>:::</p>
<h3 id="18-AQS共享锁的原理？-star-star-star-star-star-five"><a href="#18-AQS共享锁的原理？-star-star-star-star-star-five" class="headerlink" title="18. AQS共享锁的原理？:star::star::star::star::star::five:"></a>18. <code>AQS</code>共享锁的原理？:star::star::star::star::star::five:</h3><p>共享锁包括<code>Semaphore</code>&#x2F;<code>CountDownLatch</code>&#x2F;<code>ReadWriteLock</code>等，因为<code>AQS</code>已经实现了很多模板方法，如果需要定义共享锁只需要重写共享资源<code>state</code>的获取与释放和同步队列的维护。以<code>Semaphore</code>为例，当设置可同时执行<code>N</code>个线程时，那么当<code>state</code>小于<code>N</code>就可以获取锁，大于<code>N</code>需要等待阻塞。<code>CountDownLatch</code>是<code>state</code>设置为<code>N</code>，当减一时<code>state</code>-<code>1</code>，只有<code>state</code>&#x3D;<code>0</code>才开启主线程。</p>
<p><strong>题评：</strong> 无<br>::: details 点击查看详细答案<br>待补充<br>:::</p>
<h3 id="19-AQS的公平锁和非公平锁？-star-star-star-star-star-four"><a href="#19-AQS的公平锁和非公平锁？-star-star-star-star-star-four" class="headerlink" title="19. AQS的公平锁和非公平锁？:star::star::star::star::star::four:"></a>19. <code>AQS</code>的公平锁和非公平锁？:star::star::star::star::star::four:</h3><p>公平锁和非公平锁最主要体现在新来的线程是否无视队列中排队的节点直接抢占。</p>
<ul>
<li>非公平锁：新的线程来了，自旋式判断<code>state</code>是否为<code>0</code>，如果为<code>0</code>等队列中的节点还没唤醒就立即抢占了。当两次自旋还没抢占则进入队尾进行排队等候。进入了队列那么就必须按照顺序来获得锁。</li>
<li>公平锁：每次新的线程来了先判断是否有前面的节点，即头结点后是否还有节点，如果有的话表示不能抢占，于是入队进行排队，直到头结点释放锁主动唤醒才能占用锁。<br>区别就是抢锁前是否判断前面有节点在排队。</li>
</ul>
<p><strong>题评：</strong> 无<br>::: details 点击查看详细答案<br>待补充<br>:::</p>
<h3 id="20-并发容器与同步容器-star-star-star-star-star-four"><a href="#20-并发容器与同步容器-star-star-star-star-star-four" class="headerlink" title="20. 并发容器与同步容器:star::star::star::star::star::four:"></a>20. 并发容器与同步容器:star::star::star::star::star::four:</h3><ul>
<li>同步容器：通过<code>synchronized</code> 加锁实现同步，例如 <code>Vector</code>，<code>Hashtable</code>，<code>Collections</code>.<code>synchronizedSet</code> 等，都是在需要同步的方法上加<code>synchronized</code> 实现同步。特点就是简单粗暴的加锁实现，性能非常差。</li>
<li>并发容器：采用极致的优化方法提供并发的容器，例如<code>ConcurrentHashMap</code> 采用分段锁和<code>CAS</code>实现并发同步。共同点就是都提供了线程安全的集合，并发容器的可扩展性更高，并发性更好。</li>
</ul>
<p><strong>题评：</strong> 无<br>::: details 点击查看详细答案<br>待补充<br>:::</p>
<h3 id="21-SynchronizedMap-和-ConcurrentHashMap-有什么区别？-star-star-star-star-three"><a href="#21-SynchronizedMap-和-ConcurrentHashMap-有什么区别？-star-star-star-star-three" class="headerlink" title="21. SynchronizedMap 和 ConcurrentHashMap 有什么区别？  :star::star::star::star::three:"></a>21. <code>SynchronizedMap</code> 和 <code>ConcurrentHashMap</code> 有什么区别？  :star::star::star::star::three:</h3><p><code>SynchronizedMap</code> 每次修改锁中整个<code>HashMap</code>，<code>ConcurrentHashMap</code> 只是采用分段锁锁住一个<code>segment</code>，并不会影响其他的<code>segment</code>，大大提高并发率。且能避免快速失败。</p>
<p><strong>题评：</strong> 无<br>::: details 点击查看详细答案</p>
<ul>
<li>‘SynchronizedMap’ 通过对’HashMap’加’Synchronized’锁的机制每次都只能一个线程访问’HashMap’。</li>
<li>‘ConcurrentHashMap’的实现却更加精细，采用分段锁原理，它对’map’中的所有16个桶加了锁。也就意味着最好的情况下同时可以16个线程操作’HashMap’，线程仍然可以对map其他桶执行某些操作。 所以，’ConcurrentHashMap’在性能以及安全性方面，明显比’Collections.synchronizedMap()’更加有优势。同步操作精确控制到桶，这样，即使在遍历’map’时，如果其他线程试图对’map’进行数据修改，也不会抛出’ConcurrentModificationException’ 也就是’fail-fast’机制 。<br>:::</li>
</ul>
<h3 id="22-CopyOnWriteArrayList详解-star-star-star-star-four"><a href="#22-CopyOnWriteArrayList详解-star-star-star-star-four" class="headerlink" title="22. CopyOnWriteArrayList详解 :star::star::star::star::four:"></a>22. <code>CopyOnWriteArrayList</code>详解 :star::star::star::star::four:</h3><p><code>ArrayList</code> 的线程安全的版本，在<code>CopyOnWriteArrayList</code> 中，写入将导致创建整个底层数组的副本，而源数组将保留在原地，使得复制的数组在被修改时，读取操作可以安全地执行。当多个迭代器同时遍历和修改这个列表时，不会抛出<code>ConcurrentModificationException</code>。 适合读多写少的场景。缺点：由于写操作的时候，需要拷贝数组，会消耗内存，如果原数组的内容比较多的情况下，可能导致<code>young</code> <code>gc</code> 或者 <code>full</code> <code>gc</code>。每次都要复制全部数据，导致效率不高。设计思想：读写分离，复制副本来修改，避免并发冲突。</p>
<p><strong>题评：</strong> 无<br>::: details 点击查看详细答案<br>待补充<br>:::</p>
<h3 id="23-知道哪些阻塞队列？-star-star-star-star-star-four"><a href="#23-知道哪些阻塞队列？-star-star-star-star-star-four" class="headerlink" title="23. 知道哪些阻塞队列？:star::star::star::star::star::four:"></a>23. 知道哪些阻塞队列？:star::star::star::star::star::four:</h3><p>阻塞队列是支持两个附加操作的队列：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。  常见的阻塞队列如下：</p>
<ul>
<li><code>ArrayBlockingQueue</code>  ：数组实现的有界阻塞队列</li>
<li><code>LinkedBlockingQueue</code>  ：链表实现的有界|无界阻塞队列</li>
<li><code>PriorityBlockingQueue</code>  ：支持优先排序的无界阻塞队列，生产者永远不会阻塞， 只有消费者才会被阻塞。</li>
<li><code>DelayQueue</code>  ：优先队列实现的延迟无界阻塞队列，生产者永远不会阻塞， ，只有消费者才会被阻塞。只有当其指定的延迟时间到了，才能够从队列中获取到该元素。</li>
<li><code>SynchronousQueue</code>  ：不存储元素的同步阻塞队列，生产者生产一个对象放入队列，只有消费者消费了生产者才不会阻塞。一手交钱一手交货无中间商的直接交易。</li>
</ul>
<p><strong>题评：</strong> 无<br>::: details 点击查看详细答案<br>待补充<br>:::</p>
<h3 id="24-聊下Semaphore-信号量-？-star-star-star-star-three"><a href="#24-聊下Semaphore-信号量-？-star-star-star-star-three" class="headerlink" title="24. 聊下Semaphore(信号量)  ？:star::star::star::star::three:"></a>24. 聊下<code>Semaphore(</code>信号量<code>)</code>  ？:star::star::star::star::three:</h3><p>运行<code>N</code>个线程同时获取共享锁，使用<code>acquire()</code>阻塞式获取锁和<code>release()</code>方法来释放信号量。<code>tryAcquire()</code>方法在不阻塞线程的情况下尝试获锁。运行<code>N</code>个线程同时持有共享锁访问资源，如果此时超过了<code>N</code>线程陷入阻塞。</p>
<p><strong>题评：</strong> 无<br>::: details 点击查看详细答案<br>待补充<br>:::</p>
<h3 id="25-CountDownLatch-和-CyclicBarrier的区别？-star-star-star-star-star-three"><a href="#25-CountDownLatch-和-CyclicBarrier的区别？-star-star-star-star-star-three" class="headerlink" title="25. CountDownLatch 和 CyclicBarrier的区别？:star::star::star::star::star::three:"></a>25. <code>CountDownLatch</code> 和 <code>CyclicBarrier</code>的区别？:star::star::star::star::star::three:</h3><ul>
<li><code>CountDownLatch(</code>倒计时器<code>)</code>  打王者加载 :：<code>CountDownLatch</code>是一个同步工具类，用来协调多个线程之间的同步。这个工具通常用来控制线程等待，它可以让某一个线程等待直到倒计时结束，再开始执行。例如，<code>count</code>为<code>100</code>，只有<code>count</code>减为<code>0</code>了，主线程才开始执行。</li>
<li><code>CyclicBarrier(</code>循环栅栏<code>)</code>  跑马拉松：<code>CyclicBarrier</code> 和 <code>CountDownLatch</code> 非常类似，  它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。</li>
</ul>
<p><strong>题评：</strong> 无<br>::: details 点击查看详细答案<br>待补充<br>:::</p>
<h3 id="26-聊一下你认识的synchronized？-star-star-star-star-star-four"><a href="#26-聊一下你认识的synchronized？-star-star-star-star-star-four" class="headerlink" title="26. 聊一下你认识的synchronized？:star::star::star::star::star::four:"></a>26. 聊一下你认识的<code>synchronized</code>？:star::star::star::star::star::four:</h3><p>在 <code>Java</code> <code>6</code> 之后， <code>synchronized</code> 引入了大量的优化如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销，这些优化让 <code>synchronized</code> 锁的效率提升了很多。因此， <code>synchronized</code> 还是可以在实际项目中使用的，像 <code>JDK</code> 源码、很多开源框架都大量使用了 <code>synchronized</code> 。</p>
<ul>
<li><code>synchronized</code> 关键字加到 <code>static</code> 静态方法和 <code>synchronized(class)</code> 代码块上都是是给 <code>Class</code> 类上锁；加到普通方法上是对象锁级别。</li>
<li><code>synchronized</code> 关键字加到实例方法上是给对象实例上锁；</li>
<li>尽量不要使用 <code>synchronized(String</code> <code>a)</code> 因为 <code>JVM</code> 中，字符串常量池具有缓存功能。</li>
</ul>
<p><strong>题评：</strong> 无<br>::: details 点击查看详细答案<br><code>synchronized</code> 方法若发生异常，则<code>JVM</code>会自动释放锁。<code>synchronized</code>不能加在类的静态代码块，因为静态块类加载就执行，无需竞争；同步本身是不具备继承性的：即父类的<code>synchronized</code> 方法，子类重写该方法,分情况讨论：没有<code>synchonized</code>修饰，则该子类方法不是线程同步的。如果重写有<code>synchonized</code>修饰两个锁对象其实是一把锁，而且是子类对象作为锁。  </p>
<p>:::</p>
<h3 id="27-在开发过程中，你经常使用synchronized方法多还是synchronized代码块？为什么呢-star-star-star-star-star-two"><a href="#27-在开发过程中，你经常使用synchronized方法多还是synchronized代码块？为什么呢-star-star-star-star-star-two" class="headerlink" title="27. 在开发过程中，你经常使用synchronized方法多还是synchronized代码块？为什么呢?:star::star::star::star::star::two:"></a>27. 在开发过程中，你经常使用<code>synchronized</code>方法多还是<code>synchronized</code>代码块？为什么呢?:star::star::star::star::star::two:</h3><p><code>synchronized</code>代码块更多，<code>synchronized</code>同步的范围是越小越好。因为若该方法耗时很久，那其它线程必须等到该持锁线程执行完才能运行。而<code>synchronized</code>代码块部分只有这一部分是同步的，其它的照样可以异步执行，提高运行效率。</p>
<p><strong>题评：</strong> 无<br>::: details 点击查看详细答案<br>待补充<br>:::</p>
<h3 id="28-对象锁的同步队列了解吗？-star-star-star-four"><a href="#28-对象锁的同步队列了解吗？-star-star-star-four" class="headerlink" title="28. 对象锁的同步队列了解吗？:star::star::star::four:"></a>28. 对象锁的同步队列了解吗？:star::star::star::four:</h3><p>当前线程想调用对象<code>A</code>的同步方法时，发现对象<code>A</code>的锁被别的线程占有，此时当前线程进入对象锁的同步队列。简言之，同步队列里面放的都是想争夺对象锁的线程；当一个线程<code>1</code>被另外一个线程<code>2</code>唤醒时，<code>1</code>线程进入同步队列，去争夺对象锁。同步队列是在同步的环境下才有的概念，一个对象对应一个同步队列。线程等待时间到了或被<code>notify</code>&#x2F;<code>notifyAll</code>唤醒后，会从等待队列进入同步队列竞争锁，如果获得锁，进入<code>RUNNABLE</code>状态，否则进入<code>BLOCKED</code>状态等待获取锁。所以在同步队列中才是阻塞状态，在等待队列中是等待状态。</p>
<p><strong>题评：</strong> 无<br>::: details 点击查看详细答案<br>待补充<br>:::</p>
<h3 id="29-对象锁的等待队列了解吗？-star-star-two"><a href="#29-对象锁的等待队列了解吗？-star-star-two" class="headerlink" title="29. 对象锁的等待队列了解吗？:star::star::two:"></a>29. 对象锁的等待队列了解吗？:star::star::two:</h3><p>等待队列存放的是等待唤醒的线程（调用<code>wait</code>）；这个不是阻塞状态而是等待状态，由于工作中不太区分阻塞态还是等待态并且操作系统只有阻塞态，因此一律称为阻塞状态；</p>
<p><strong>题评：</strong> 无<br>::: details 点击查看详细答案<br>待补充<br>:::</p>
<h3 id="30-为什么wait和notify方法要在同步块中调用？-star-star-star-three"><a href="#30-为什么wait和notify方法要在同步块中调用？-star-star-star-three" class="headerlink" title="30. 为什么wait和notify方法要在同步块中调用？:star::star::star::three:"></a>30. 为什么<code>wait</code>和<code>notify</code>方法要在同步块中调用？:star::star::star::three:</h3><p>当一个线程需要调用对象的<code>wait()</code>方法的时候，这个线程必须拥有该对象的锁，接着它就会释放这个对象锁并进入等待状态直到其他线程调用这个对象上的<code>notify()</code>方法。而使用<code>notify</code>唤醒某个对象，此时它并不会释放这个对象锁，而仅仅是通知某个对象唤醒进入同步队列去竞争锁。<code>Synchronized</code>的语义底层是通过一个<code>monitor</code>的对象来完成，其实<code>wait</code>&#x2F;<code>notify</code>等方法也依赖于<code>monitor</code>对象，这就是为什么只有在同步的块或者方法中才能调用<code>wait</code>&#x2F;<code>notify</code>等方法。</p>
<p><strong>题评：</strong> 暂无<br>::: details 点击查看详细答案<br>待补充<br>:::</p>
<h3 id="31-为什么在循环中检查等待条件？-star-star-star-star-three"><a href="#31-为什么在循环中检查等待条件？-star-star-star-star-three" class="headerlink" title="31. 为什么在循环中检查等待条件？:star::star::star::star::three:"></a>31. 为什么在循环中检查等待条件？:star::star::star::star::three:</h3><p>因为操作系统的调度可能唤醒多个线程，即使没有显示使用<code>notify</code>。这个时候如果是<code>if</code>判断等待条件，那么第二次唤醒，就算不满足条件也会直接执行任务代码。而使用<code>while</code>循环，无论多少次唤醒都需要判断等待条件才能执行任务代码；</p>
<p><strong>题评：</strong> 无<br>::: details 点击查看详细答案<br>待补充<br>:::</p>
<h3 id="32-Synchronized的作用主要有哪些？-star-star-star-two"><a href="#32-Synchronized的作用主要有哪些？-star-star-star-two" class="headerlink" title="32. Synchronized的作用主要有哪些？:star::star::star::two:"></a>32. <code>Synchronized</code>的作用主要有哪些？:star::star::star::two:</h3><ul>
<li>原子性：保证线程互斥访问同步块。</li>
<li>可见性：保证共享变量的修改能够及时可见。</li>
<li>有序性：避免指令重排。</li>
</ul>
<p><strong>题评：</strong> 无<br>::: details 点击查看详细答案<br>待补充<br>:::</p>
<h3 id="33-Java对象头与锁和监视器的关系？-star-star-star-three"><a href="#33-Java对象头与锁和监视器的关系？-star-star-star-three" class="headerlink" title="33. Java对象头与锁和监视器的关系？:star::star::star::three:"></a>33. <code>Java</code>对象头与锁和监视器的关系？:star::star::star::three:</h3><p>对象头中有个字段是<code>MarkWord</code>，而监视器对象是<code>MarkWord</code>中的一个对象，每个对象都有一把隐式锁指定，这个锁就是监视器。但是<code>Synchronized</code>中只有重量级锁才涉及到监视器。</p>
<p><strong>题评：</strong> 无<br>::: details 点击查看详细答案<br>待补充<br>:::</p>
<h3 id="34-Synchronized-锁优化了解吗？-star-star-star-three"><a href="#34-Synchronized-锁优化了解吗？-star-star-star-three" class="headerlink" title="34. Synchronized 锁优化了解吗？:star::star::star::three:"></a>34. <code>Synchronized</code> 锁优化了解吗？:star::star::star::three:</h3><p>锁升级（锁优化）：无锁—&gt;偏向锁—&gt;轻量级锁—&gt;重量级锁；<br>其他的补充优化：自旋锁—&gt;适应性自旋锁；锁消除，锁膨胀；</p>
<p><strong>题评：</strong> 无<br>::: details 点击查看详细答案<br>待补充<br>:::</p>
<h3 id="35-导致并发修改的原因？-star-star-star-four"><a href="#35-导致并发修改的原因？-star-star-star-four" class="headerlink" title="35. 导致并发修改的原因？:star::star::star::four:"></a>35. 导致并发修改的原因？:star::star::star::four:</h3><p>一个操作不是原子性的，<code>CPU</code>上下文切换导致指令交错执行。例如 <code>a</code>++，底层包括三个操作，从内存中读取值，+<code>1</code>操作，将运算后的结果写入内存。并发情况下，将导致读的是同一个值进行修改，最后后提交的将覆盖前面的值。</p>
<p><strong>题评：</strong> 无<br>::: details 点击查看详细答案<br>待补充<br>:::</p>
<h3 id="36-聊聊synchronized关键字？-star-star-star-star-star-three"><a href="#36-聊聊synchronized关键字？-star-star-star-star-star-three" class="headerlink" title="36. 聊聊synchronized关键字？:star::star::star::star::star::three:"></a>36. 聊聊<code>synchronized</code>关键字？:star::star::star::star::star::three:</h3><p>每个对象的对象头中都有一个锁标识字段，因此一个对象可以表示一把锁，<code>synchronized</code>就是使用的就是<code>Java</code>的内置锁。使用<code>synchronized</code>修饰的代码块同一时间只能有一个线程进入，其他线程排队等待。普通方法上使用的是<code>this</code>对象锁，静态方法上使用的是<code>Class</code>对象锁，同步块中的监视锁可以自己设置。<code>synchronized</code>不必担心锁释放问题，当同步块执行完毕或者出现异常时自动释放。</p>
<p><strong>题评：</strong> 无<br>::: details 点击查看详细答案<br>待补充<br>:::</p>
<h3 id="37-如何判断变量是否线程安全？-star-star-star-star-three"><a href="#37-如何判断变量是否线程安全？-star-star-star-star-three" class="headerlink" title="37. 如何判断变量是否线程安全？:star::star::star::star::three:"></a>37. 如何判断变量是否线程安全？:star::star::star::star::three:</h3><ul>
<li>没有共享—线程安全 （局部变量）<br>  <code>a</code>. 局部变量引用的对象有逃离方法作用域暴露出去—非线程安全</li>
<li>有共享 （成员变量|静态变量）<br>  <code>a</code>. 只读操作—线程安全<br>  <code>b</code>. 有写操作—非线程安全</li>
</ul>
<p><strong>题评：</strong> 无<br>::: details 点击查看详细答案<br>待补充<br>:::</p>
<h3 id="38-有哪些线程安全的类-star-star-star-star-three"><a href="#38-有哪些线程安全的类-star-star-star-star-three" class="headerlink" title="38. 有哪些线程安全的类?:star::star::star::star::three:"></a>38. 有哪些线程安全的类?:star::star::star::star::three:</h3><p>不可变类：<code>String</code>，基本数据类型包装类<br><code>StringBuffer</code>、<code>Random</code>、<code>Vecotr</code>、<code>Hashtable</code>、<code>JUC</code></p>
<p><strong>题评：</strong> 无<br>::: details 点击查看详细答案<br>待补充<br>:::</p>
<h3 id="39-对象头结构与锁了解吗？-star-star-four"><a href="#39-对象头结构与锁了解吗？-star-star-four" class="headerlink" title="39. 对象头结构与锁了解吗？:star::star::four:"></a>39. 对象头结构与锁了解吗？:star::star::four:</h3><p>对象头中的<code>MarkWord</code>用于存储对象的<code>HashCode</code>和内置锁信息，不同的锁占用的位数不一样，偏向锁存储的是持有锁的线程<code>ID</code>，轻量级锁存储的是栈中锁记录指针，重量级锁存储指向监视器指针。</p>
<p><strong>题评：</strong> 无<br>::: details 点击查看详细答案<br>待补充<br>:::</p>
<h3 id="40-四种内置锁了解吗？-star-star-star-star-three"><a href="#40-四种内置锁了解吗？-star-star-star-star-three" class="headerlink" title="40. 四种内置锁了解吗？:star::star::star::star::three:"></a>40. 四种内置锁了解吗？:star::star::star::star::three:</h3><ul>
<li>无锁，未加锁状态</li>
<li>偏向锁，当一个对象锁第一次被获取时会在对象头的<code>MarkWord</code>表示字段中记录此<code>A</code>线程<code>ID</code>表示偏向了<code>A</code>，当它下次获取锁时直接获取；而此时如果锁未被占用，线程<code>B</code>来获取会导致偏向锁的重偏向，最终线程<code>B</code>通过<code>CAS</code>来获得锁。如果是<code>A</code>持有锁，<code>B</code>也来竞争则导致偏向锁的锁升级。</li>
<li>轻量级锁，对象头中存储的是栈中的锁记录，竞争锁的方式为<code>CAS</code>自旋适合占用锁很短时间的情况，避免上下文切换。通过引入自适应自旋来优化。当大量线程竞争是，自旋超过指定时间还没有获取锁时会失败，此时锁膨胀为重量级锁。</li>
<li>重量级锁会让其他申请的线程之间进入阻塞，性能降低。重量级锁也就叫同步锁，这个锁对象<code>Mark</code> <code>Word</code>再次发生变化，会指向一个监视器对象，该监视器对象用集合的形式来登记和管理排队的线程，同步队列</li>
</ul>
<p><strong>题评：</strong> 无<br>::: details 点击查看详细答案<br>待补充<br>:::</p>
<h3 id="41-聊一聊偏向锁？-star-star-star-two"><a href="#41-聊一聊偏向锁？-star-star-star-two" class="headerlink" title="41. 聊一聊偏向锁？:star::star::star::two:"></a>41. 聊一聊偏向锁？:star::star::star::two:</h3><p>如果是同一个线程多次获得锁，如果不是偏向锁将会导致无限制的获取锁、释放锁操作，这将导致无竞争情况下的系统底层的同步操作，性能很低。如果使用偏向锁，之前获得锁的线程再次获得锁时会判断偏向锁的线程<code>ID</code>是否指向自己。如果指向自己，拿锁成功。如果未指向当前线程，则判断是否该线程占用是否已经结束了。如果结束了当前线程会采用<code>CAS</code>操作将<code>Mark</code> <code>Word</code>中线程<code>ID</code>设置为当前线程<code>ID</code>，如果<code>CAS</code>操作成功，那么获取偏向锁成功，去执行同步代码块，如果当前线程没有结束，那么表示有竞争，抢锁线程被挂起，撤销占锁线程的偏向锁，然后将偏向锁膨胀为轻量级锁。</p>
<p><strong>题评：</strong> 无<br>::: details 点击查看详细答案<br>待补充<br>:::</p>
<h3 id="42-偏向锁的撤销？-star-star-star-four"><a href="#42-偏向锁的撤销？-star-star-star-four" class="headerlink" title="42. 偏向锁的撤销？:star::star::star::four:"></a>42. 偏向锁的撤销？:star::star::star::four:</h3><ul>
<li>多线程竞争偏向锁，偏向锁膨胀为轻量级锁</li>
<li>调用偏向锁对象的<code>hashCode</code>方法，因为<code>MarkWork</code>线程<code>ID</code>占了<code>54</code>为撤销存放哈希值。</li>
<li>调用<code>wati</code>&#x2F;<code>notify</code>，需要申请监视器，进入等待队列</li>
</ul>
<p><strong>题评：</strong> 无<br>::: details 点击查看详细答案<br>待补充<br>:::</p>
<h3 id="43-轻量级锁原理-star-star-star-three"><a href="#43-轻量级锁原理-star-star-star-three" class="headerlink" title="43. 轻量级锁原理:star::star::star::three:"></a>43. 轻量级锁原理:star::star::star::three:</h3><p>通过<code>CAS</code>修改对象头中的锁记录指针来竞争锁，避免用户态到内核态的频繁切换，当大量线程争夺锁时，自旋时间达到一定值会升级为重量级锁。适用于锁占用时间很短的多线程情景。整个过程没有阻塞挂起线程。</p>
<p><strong>题评：</strong> 无<br>::: details 点击查看详细答案<br>待补充<br>:::</p>
<h3 id="44-synchronized的底层原理-重量级锁原理？-star-star-star-star-four"><a href="#44-synchronized的底层原理-重量级锁原理？-star-star-star-star-four" class="headerlink" title="44. synchronized的底层原理 | 重量级锁原理？:star::star::star::star::four:"></a>44. <code>synchronized</code>的底层原理 | 重量级锁原理？:star::star::star::star::four:</h3><p><code>Monitor</code> 有<code>Owner</code>、<code>EntryList</code>、<code>WaitSet</code>三部分组成。<code>Owner</code>指向的是当前获取锁的线程，<code>EntryList</code>是争夺锁的线程进入排队的容器，同步队列。<code>WaitSet</code>存放调用<code>wait()</code>方法之后将被阻塞的线程，等待队列，被唤醒时进入<code>EntryList</code>重新竞争锁。总结：线程<code>X</code>执行到某个对象的临界区，获取锁的原理是：先通过此对象的<code>Mark</code> <code>word</code>的<code>Monitor</code>指针找到<code>Monitor</code>，然后检查<code>Owner</code>是否指向某个线程<code>ID</code>，如果有线程<code>ID</code>值则阻塞，将线程<code>X</code>加入到<code>EntryList</code>链表中同步等待。不同对象不同的锁（<code>Monitor</code>对象），类对象所有实例共享一个<code>Monitor</code>对象。</p>
<p><strong>题评：</strong> 无<br>::: details 点击查看详细答案<br>待补充<br>:::</p>
<h3 id="45-synchronized执行过程？-star-star-star-star-four"><a href="#45-synchronized执行过程？-star-star-star-star-four" class="headerlink" title="45. synchronized执行过程？:star::star::star::star::four:"></a>45. <code>synchronized</code>执行过程？:star::star::star::star::four:</h3><p>抢锁时先判断是不是偏向锁，如果是再判断是不是线程<code>ID</code>指向自己，如果是抢锁成功。如果不是那么判断此时锁是否被占用，如果没有占用进行<code>CAS</code>重偏向，否则膨胀为轻量级锁。轻量级锁是通过<code>CAS</code>自旋实现的，<code>MarkWord</code>中记录的是锁记录指针，如果<code>CAS</code>自旋超时失败则升级为重量级锁。重量级锁记录的是监视器对象，包括<code>Owner</code>、<code>EntryList</code>、<code>WaitSet</code>三个属性。</p>
<p><strong>题评：</strong> 主要答锁升级的过程！<br>::: details 点击查看详细答案<br>待补充<br>:::</p>
<h3 id="46-锁消除了解吗？-star-star-star-three"><a href="#46-锁消除了解吗？-star-star-star-three" class="headerlink" title="46. 锁消除了解吗？:star::star::star::three:"></a>46. 锁消除了解吗？:star::star::star::three:</h3><p>被检测出不可能存在竞争的共享数据的锁进行消除，这是 <code>JVM</code> 即时编译器的优化。锁消除主要是通过逃逸分析来支持，如果堆上的共享数据不可能逃逸出去被其它线程访问到，那么就可以把它们当成私有数据对待，也就可以将它们的锁进行消除。例如在单线程代码块中加锁，会进行优化，锁消除。</p>
<p><strong>题评：</strong> 无<br>::: details 点击查看详细答案<br>待补充<br>:::</p>
<h3 id="47-锁粗化了解吗？-star-star-star-three"><a href="#47-锁粗化了解吗？-star-star-star-three" class="headerlink" title="47. 锁粗化了解吗？:star::star::star::three:"></a>47. 锁粗化了解吗？:star::star::star::three:</h3><p>对相同对象多次加锁，导致线程发生多次重入，频繁的加锁操作就会导致性能损耗，可以使用锁粗化方式优化如果虚拟机探测到一串的操作都对同一个对象加锁，将会把加锁的范围扩展（粗化）到整个操作序列的外部。</p>
<p><strong>题评：</strong> 无<br>::: details 点击查看详细答案<br>待补充<br>:::</p>
<h3 id="48-了解Semaphore吗？-star-star-star-star-three"><a href="#48-了解Semaphore吗？-star-star-star-star-three" class="headerlink" title="48. 了解Semaphore吗？:star::star::star::star::three:"></a>48. 了解<code>Semaphore</code>吗？:star::star::star::star::three:</h3><p><code>Semaphore</code>就是一个信号量，它的作用是限制某段代码块的并发数。<code>Semaphore</code>有一个构造函数，可以传入一个<code>int</code>型整数<code>n</code>，表示某段代码最多只有<code>n</code>个线程可以访问，如果超出了<code>n</code>，那么请等待，等到某个线程执行完毕这段代码块，下一个线程再进入。由此可以看出如果<code>Semaphore</code>构造函数中传入的<code>int</code>型整数<code>n</code>&#x3D;<code>1</code>，相当于变成了一个<code>synchronized</code>了。</p>
<p><strong>题评：</strong> 无<br>::: details 点击查看详细答案<br>待补充<br>:::</p>
<h3 id="49-Future-类有什么用？-star-star-star-star-three"><a href="#49-Future-类有什么用？-star-star-star-star-three" class="headerlink" title="49. Future 类有什么用？:star::star::star::star::three:"></a>49. <code>Future</code> 类有什么用？:star::star::star::star::three:</h3><p><code>Future</code> 类是异步思想的典型运用，主要用在一些需要执行耗时任务的场景，避免程序一直原地等待耗时任务执行完成，执行效率太低。具体来说是这样的：当我们执行某一耗时的任务时，可以将这个耗时任务交给一个子线程去异步执行，同时我们可以干点其他事情，不用傻傻等待耗时任务执行完成。等我们的事情干完后，我们再通过 <code>Future</code> 类获取到耗时任务的执行结果。这样一来，程序的执行效率就明显提高了。</p>
<p><strong>题评：</strong> 无<br>::: details 点击查看详细答案<br>待补充<br>:::</p>
<h3 id="50-什么是阻塞队列？-star-star-star-star-two"><a href="#50-什么是阻塞队列？-star-star-star-star-two" class="headerlink" title="50. 什么是阻塞队列？:star::star::star::star::two:"></a>50. 什么是阻塞队列？:star::star::star::star::two:</h3><p>阻塞队列（<code>BlockingQueue</code>）是一个支持两个附加操作的队列。这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。</p>
<p><strong>题评：</strong> 无<br>::: details 点击查看详细答案<br>待补充<br>:::</p>
<h3 id="51-阻塞队列的实现原理是什么？-star-star-star-three"><a href="#51-阻塞队列的实现原理是什么？-star-star-star-three" class="headerlink" title="51. 阻塞队列的实现原理是什么？:star::star::star::three:"></a>51. 阻塞队列的实现原理是什么？:star::star::star::three:</h3><p>实现原理：其实阻塞队列实现阻塞同步的方式很简单，使用的就是是<code>lock</code>锁的多条件（<code>condition</code>）阻塞控制。它用来替代传统的<code>Object</code>的<code>wait()</code>、<code>notify()</code>实现线程间的协作，相比使用<code>Object</code>的<code>wait()</code>、<code>notify()</code>，使用<code>Condition</code>的<code>await()</code>、<code>signal()</code>这种方式实现线程间协作更加安全和高效。使用<code>BlockingQueue</code>封装了根据条件阻塞线程的过程，而我们就不用关心繁琐的<code>await</code>&#x2F;<code>signal</code>操作了。 </p>
<p><strong>题评：</strong> 无<br>::: details 点击查看详细答案<br>待补充<br>:::</p>
<h3 id="52-乐观锁和悲观锁的理解及如何实现，有哪些实现方式？-star-star-star-star-three"><a href="#52-乐观锁和悲观锁的理解及如何实现，有哪些实现方式？-star-star-star-star-three" class="headerlink" title="52. 乐观锁和悲观锁的理解及如何实现，有哪些实现方式？:star::star::star::star::three:"></a>52. 乐观锁和悲观锁的理解及如何实现，有哪些实现方式？:star::star::star::star::three:</h3><ul>
<li>悲观锁：每次修改数据都加锁，其他线程在对象锁被持有的情况下无法访问数据，需要等待它释放锁后抢锁才能访问数据。例如<code>synchronized</code>、<code>ReenterLock</code>加锁都是悲观锁，还有数据库的行锁、表锁等。</li>
<li>乐观锁：每次访问数据都不加锁，提交数据时才判断是否期间已经被其他线程访问过，如果访问失败则重新竞争访问呢。普通乐观锁使用数据本身作为版本号会出现<code>ABA</code>问题，而版本号法式递增的过程不会出现<code>ABA</code>问题。<code>Java</code> <code>JUC</code>中有<code>Compare</code> <code>and</code> <code>Swap</code>的实现。</li>
<li>乐观锁版本号机制：一般是在数据表中加上一个数据版本号 <code>version</code> 字段，表示数据被修改的次数。当数据被修改时，<code>version</code> 值会加一。当线程 <code>A</code> 要更新数据值时，在读取数据的同时也会读取 <code>version</code> 值，在提交更新时，若刚才读取到的 <code>version</code> 值为当前数据库中的 <code>version</code> 值相等时才更新，否则重试更新操作，直到更新成功。</li>
</ul>
<p><strong>题评：</strong> 无<br>::: details 点击查看详细答案<br>待补充<br>:::</p>
<h3 id="53-如何禁止指令重排序？-star-star-star-star-four"><a href="#53-如何禁止指令重排序？-star-star-star-star-four" class="headerlink" title="53. 如何禁止指令重排序？:star::star::star::star::four:"></a>53. 如何禁止指令重排序？:star::star::star::star::four:</h3><p>在 <code>Java</code> 中，<code>volatile</code> 关键字除了可以保证变量的可见性，还有一个重要的作用就是防止 <code>JVM</code> 的指令重排序。 如果我们将变量声明为 <code>volatile</code> ，在对这个变量进行读写操作的时候，会通过插入特定的 内存屏障 的方式来禁止指令重排序。例如被<code>volatile</code>修饰的变量，假设它不是一个原子操作，需要三步；并发的时候，如果需要读这个值需要先等写完毕才能读，因此能保证写和读的顺序，通过 <code>ll</code> <code>ls</code> <code>sl</code> <code>ss</code> 指令进行内存屏障，禁止普通读写、<code>volatile</code>读写。</p>
<p><strong>题评：</strong> 无<br>::: details 点击查看详细答案<br>待补充<br>:::</p>
<h3 id="54-公平锁与非公平锁的区别和原理？-star-star-star-star-four"><a href="#54-公平锁与非公平锁的区别和原理？-star-star-star-star-four" class="headerlink" title="54. 公平锁与非公平锁的区别和原理？:star::star::star::star::four:"></a>54. 公平锁与非公平锁的区别和原理？:star::star::star::star::four:</h3><ul>
<li>公平锁 : 锁被释放之后，先申请的线程先得到锁。性能较差一些，因为公平锁为了保证时间上的绝对顺序，上下文切换更频繁。</li>
<li>非公平锁 ：锁被释放之后，后申请的线程可能会先获取到锁，是随机或者按照其他优先级排序的。性能更好，但可能会导致某些线程永远无法获取到锁。<br>原理：</li>
<li>公平锁，每次判断<code>state</code>为<code>0</code>时不能立即抢占，而是判断是否还有前置结点，也就是判断首节点后面是否还有结点排队等候，如果有通过<code>cas</code>入队。</li>
<li>非公平锁，新线程来了，不管有没有其他结点在<code>CLH</code>链表上排队先<code>cas</code>抢占，如果两次强锁失败，那么就进入到队列中，其实这和公平锁一样啦，需要排队。当没有新的线程抢占时，强锁也是按照队列先后顺序来抢的，类似公平锁。<br>非公平锁和公平锁 最大的区别就是新来的线程是不是插队抢占，如果它没抢到那后面就是老老实实排队，后面唤醒也要等前面的结点出队了才能唤醒，而且入队的结点可能存在饥饿。</li>
</ul>
<p><strong>题评：</strong> 无<br>::: details 点击查看详细答案<br>待补充<br>:::</p>
<h3 id="55-构造方法可以用-synchronized-修饰么？-star-star-star-two"><a href="#55-构造方法可以用-synchronized-修饰么？-star-star-star-two" class="headerlink" title="55. 构造方法可以用 synchronized 修饰么？:star::star::star::two:"></a>55. 构造方法可以用 <code>synchronized</code> 修饰么？:star::star::star::two:</h3><p>构造方法不能使用 <code>synchronized</code> 关键字修饰。构造方法本身就属于线程安全的，不存在同步的构造方法一说。</p>
<p><strong>题评：</strong> 无<br>::: details 点击查看详细答案<br>待补充<br>:::</p>
<h3 id="56-JDK1-6-之后的-synchronized-底层做了哪些优化？-star-star-star-star-three"><a href="#56-JDK1-6-之后的-synchronized-底层做了哪些优化？-star-star-star-star-three" class="headerlink" title="56. JDK1.6 之后的 synchronized 底层做了哪些优化？:star::star::star::star::three:"></a>56. <code>JDK1</code>.<code>6</code> 之后的 <code>synchronized</code> 底层做了哪些优化？:star::star::star::star::three:</h3><p><code>JDK1</code>.<code>6</code> 对锁的实现引入了大量的优化，如偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术来减少锁操作的开销。锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。</p>
<p><strong>题评：</strong> 无<br>::: details 点击查看详细答案<br>待补充<br>:::</p>
<h3 id="57-可中断锁和不可中断锁有什么区别？-star-star-star-star-three"><a href="#57-可中断锁和不可中断锁有什么区别？-star-star-star-star-three" class="headerlink" title="57. 可中断锁和不可中断锁有什么区别？:star::star::star::star::three:"></a>57. 可中断锁和不可中断锁有什么区别？:star::star::star::star::three:</h3><ul>
<li>可中断锁 ：获取锁的过程中可以被中断，不需要一直等到获取锁之后 才能进行其他逻辑处理。<code>ReentrantLock</code> 就属于是可中断锁。</li>
<li>不可中断锁 ：一旦线程申请了锁，就只能等到拿到锁以后才能进行其他的逻辑处理。 <code>synchronized</code> 就属于是不可中断锁。</li>
</ul>
<p><strong>题评：</strong> 无<br>::: details 点击查看详细答案<br>待补充<br>:::</p>
<h3 id="58-线程持有读锁还能获取写锁吗？-star-star-star-four"><a href="#58-线程持有读锁还能获取写锁吗？-star-star-star-four" class="headerlink" title="58. 线程持有读锁还能获取写锁吗？:star::star::star::four:"></a>58. 线程持有读锁还能获取写锁吗？:star::star::star::four:</h3><p>本线程持有读锁不能获取写锁，持有写锁可以继续获取读锁。 写锁可以降级为读锁，但是读锁却不能升级为写锁。这是因为读锁升级为写锁会引起线程的争夺，毕竟写锁属于是独占锁。但是写锁可以降级成读锁。读写锁只能锁降级：拥有写锁-&gt;获取读锁-&gt;释放写锁。  因此拥有写锁可以获取读锁。 </p>
<p><strong>题评：</strong> 无<br>::: details 点击查看详细答案<br>待补充<br>:::</p>
<h3 id="59-Thread类中的yield方法有什么作用？-star-star-star-three"><a href="#59-Thread类中的yield方法有什么作用？-star-star-star-three" class="headerlink" title="59. Thread类中的yield方法有什么作用？:star::star::star::three:"></a>59. <code>Thread</code>类中的<code>yield</code>方法有什么作用？:star::star::star::three:</h3><p><code>Yield</code>方法可以暂停当前正在执行的线程对象，让其它有相同优先级的线程执行。它是一个静态方法而且只保证当前线程放弃<code>CPU</code>占用而不能保证使其它线程一定能占用<code>CPU</code>，执行<code>yield()</code>的线程有可能在进入到暂停状态后马上又被执行。</p>
<p><strong>题评：</strong> 无<br>::: details 点击查看详细答案<br>待补充<br>:::</p>
<h3 id="60-线程安全需要保证几个基本特征？-star-star-star-three"><a href="#60-线程安全需要保证几个基本特征？-star-star-star-three" class="headerlink" title="60. 线程安全需要保证几个基本特征？:star::star::star::three:"></a>60. 线程安全需要保证几个基本特征？:star::star::star::three:</h3><ul>
<li>原子性，简单说就是相关操作不会中途被其他线程干扰，一般通过同步机制实现。</li>
<li>可见性，是一个线程修改了某个共享变量，其状态能够立即被其他线程知晓，通常被解释为将线程本地状态反映到主内存上，<code>volatile</code> 就是负责保证可见性的。</li>
<li>有序性，是保证线程内串行语义，避免指令重排等。</li>
</ul>
<p><strong>题评：</strong> 无<br>::: details 点击查看详细答案<br>待补充<br>:::</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://mo0ling.github.io">墨凌</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://mo0ling.github.io/posts/918971b1.html">https://mo0ling.github.io/posts/918971b1.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://mo0ling.github.io" target="_blank">墨凌的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java-%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80-%E5%9F%BA%E7%A1%80/">java 开发语言 基础</a></div><div class="post_share"><div class="social-share" data-image="https://source.fomal.cc/img/default_cover_14.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/a1ede006.html" title="HTTP"><img class="cover" src="https://source.fomal.cc/img/default_cover_14.webp" onerror="onerror=null;src='/assets/r2.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">HTTP</div></div></a></div><div class="next-post pull-right"><a href="/posts/364ea8cc.html" title="设计模式"><img class="cover" src="https://source.fomal.cc/img/default_cover_14.webp" onerror="onerror=null;src='/assets/r2.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">设计模式</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%AF%B7%E8%AF%B4%E4%B8%80%E4%B8%8BCAS%E5%8E%9F%E7%90%86%EF%BC%9F-star-star-star-star-two"><span class="toc-number">1.</span> <span class="toc-text">1. 请说一下CAS原理？:star::star::star::star::two:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-CAS%E4%B8%AD%E7%9A%84ABA%E9%97%AE%E9%A2%98%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-star-star-star-two"><span class="toc-number">2.</span> <span class="toc-text">2. CAS中的ABA问题是什么？:star::star::star::two:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%AE%B2%E4%B8%80%E4%B8%8BJUC%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%AD%90%E7%B1%BB%EF%BC%9F-star-star-star-two"><span class="toc-number">3.</span> <span class="toc-text">3. 讲一下JUC中的原子类？:star::star::star::two:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-LongAdder-%E7%9A%84%E5%8E%9F%E7%90%86%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F-star-star-three"><span class="toc-number">4.</span> <span class="toc-text">4. LongAdder 的原理了解吗？:star::star::three:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BB%A3%E7%A0%81%E4%BC%9A%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%EF%BC%9F-star-star-star-star-four"><span class="toc-number">5.</span> <span class="toc-text">5. 为什么代码会指令重排？:star::star::star::star::four:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E8%AE%B2%E8%A7%A3%E4%B8%80%E4%B8%8B-Volatile%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F-star-star-star-star-four"><span class="toc-number">6.</span> <span class="toc-text">6. 讲解一下 Volatile关键字的作用？:star::star::star::star::four:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-Java%E4%B8%AD%E5%8F%AF%E4%BB%A5%E4%BF%9D%E8%AF%81%E6%95%B0%E7%BB%84%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7%E5%90%97%EF%BC%9F-star-star-star-three"><span class="toc-number">7.</span> <span class="toc-text">7. Java中可以保证数组的可见性吗？:star::star::star::three:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-volatile-%E8%83%BD%E4%BD%BF%E5%BE%97%E4%B8%80%E4%B8%AA%E9%9D%9E%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E5%8F%98%E6%88%90%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E5%90%97%EF%BC%9F-star-star-star-three"><span class="toc-number">8.</span> <span class="toc-text">8. volatile 能使得一个非原子操作变成原子操作吗？  :star::star::star::three:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E5%9C%A8%E5%93%AA%E9%87%8C%E4%BD%BF%E7%94%A8%E8%BF%87volatile%E4%BF%AE%E9%A5%B0%E7%AC%A6%EF%BC%9F-star-star-star-star-three"><span class="toc-number">9.</span> <span class="toc-text">9. 在哪里使用过volatile修饰符？:star::star::star::star::three:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-synchronized-%E5%92%8C-volatile-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-star-star-star-star-star-three"><span class="toc-number">10.</span> <span class="toc-text">10. synchronized 和 volatile 的区别是什么？ :star::star::star::star::star::three:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1-Immutable-Objects-%EF%BC%9F-star-star-star-three"><span class="toc-number">11.</span> <span class="toc-text">11. 什么是不可变对象(Immutable Objects)  ？:star::star::star::three:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-Lock%E6%8E%A5%E5%8F%A3%E7%94%A8%E8%BF%87%E5%90%97%EF%BC%9F%E4%B8%8Esynchronized-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F-star-star-star-star-star-three"><span class="toc-number">12.</span> <span class="toc-text">12. Lock接口用过吗？与synchronized 有什么区别？:star::star::star::star::star::three:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%EF%BC%9F-star-star-star-star-three"><span class="toc-number">13.</span> <span class="toc-text">13. 什么是可重入锁？:star::star::star::star::three:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-ReadWriteLock-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E6%9C%89ReentrantLock-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81ReadWriteLock%EF%BC%9F-star-star-star-three"><span class="toc-number">14.</span> <span class="toc-text">14. ReadWriteLock 是什么，有ReentrantLock  为什么需要ReadWriteLock？:star::star::star::three:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-%E6%9C%89%E6%B2%A1%E6%9C%89%E4%BA%86%E8%A7%A3CLH%E9%98%9F%E5%88%97%EF%BC%9F-star-star-four"><span class="toc-number">15.</span> <span class="toc-text">15. 有没有了解CLH队列？:star::star::four:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-AQS%E6%8A%BD%E8%B1%A1%E5%90%8C%E6%AD%A5%E9%98%9F%E5%88%97%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-star-star-star-star-star-four"><span class="toc-number">16.</span> <span class="toc-text">16. AQS抽象同步队列是什么？:star::star::star::star::star::four:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-ConcurrentHashMap%E5%8E%9F%E7%90%86-star-star-star-star-star-three"><span class="toc-number">17.</span> <span class="toc-text">17. ConcurrentHashMap原理:star::star::star::star::star::three:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-AQS%E5%85%B1%E4%BA%AB%E9%94%81%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%9F-star-star-star-star-star-five"><span class="toc-number">18.</span> <span class="toc-text">18. AQS共享锁的原理？:star::star::star::star::star::five:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-AQS%E7%9A%84%E5%85%AC%E5%B9%B3%E9%94%81%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%EF%BC%9F-star-star-star-star-star-four"><span class="toc-number">19.</span> <span class="toc-text">19. AQS的公平锁和非公平锁？:star::star::star::star::star::four:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E4%B8%8E%E5%90%8C%E6%AD%A5%E5%AE%B9%E5%99%A8-star-star-star-star-star-four"><span class="toc-number">20.</span> <span class="toc-text">20. 并发容器与同步容器:star::star::star::star::star::four:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-SynchronizedMap-%E5%92%8C-ConcurrentHashMap-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F-star-star-star-star-three"><span class="toc-number">21.</span> <span class="toc-text">21. SynchronizedMap 和 ConcurrentHashMap 有什么区别？  :star::star::star::star::three:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-CopyOnWriteArrayList%E8%AF%A6%E8%A7%A3-star-star-star-star-four"><span class="toc-number">22.</span> <span class="toc-text">22. CopyOnWriteArrayList详解 :star::star::star::star::four:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-%E7%9F%A5%E9%81%93%E5%93%AA%E4%BA%9B%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%EF%BC%9F-star-star-star-star-star-four"><span class="toc-number">23.</span> <span class="toc-text">23. 知道哪些阻塞队列？:star::star::star::star::star::four:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-%E8%81%8A%E4%B8%8BSemaphore-%E4%BF%A1%E5%8F%B7%E9%87%8F-%EF%BC%9F-star-star-star-star-three"><span class="toc-number">24.</span> <span class="toc-text">24. 聊下Semaphore(信号量)  ？:star::star::star::star::three:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25-CountDownLatch-%E5%92%8C-CyclicBarrier%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F-star-star-star-star-star-three"><span class="toc-number">25.</span> <span class="toc-text">25. CountDownLatch 和 CyclicBarrier的区别？:star::star::star::star::star::three:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26-%E8%81%8A%E4%B8%80%E4%B8%8B%E4%BD%A0%E8%AE%A4%E8%AF%86%E7%9A%84synchronized%EF%BC%9F-star-star-star-star-star-four"><span class="toc-number">26.</span> <span class="toc-text">26. 聊一下你认识的synchronized？:star::star::star::star::star::four:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#27-%E5%9C%A8%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E4%B8%AD%EF%BC%8C%E4%BD%A0%E7%BB%8F%E5%B8%B8%E4%BD%BF%E7%94%A8synchronized%E6%96%B9%E6%B3%95%E5%A4%9A%E8%BF%98%E6%98%AFsynchronized%E4%BB%A3%E7%A0%81%E5%9D%97%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E5%91%A2-star-star-star-star-star-two"><span class="toc-number">27.</span> <span class="toc-text">27. 在开发过程中，你经常使用synchronized方法多还是synchronized代码块？为什么呢?:star::star::star::star::star::two:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#28-%E5%AF%B9%E8%B1%A1%E9%94%81%E7%9A%84%E5%90%8C%E6%AD%A5%E9%98%9F%E5%88%97%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F-star-star-star-four"><span class="toc-number">28.</span> <span class="toc-text">28. 对象锁的同步队列了解吗？:star::star::star::four:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#29-%E5%AF%B9%E8%B1%A1%E9%94%81%E7%9A%84%E7%AD%89%E5%BE%85%E9%98%9F%E5%88%97%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F-star-star-two"><span class="toc-number">29.</span> <span class="toc-text">29. 对象锁的等待队列了解吗？:star::star::two:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#30-%E4%B8%BA%E4%BB%80%E4%B9%88wait%E5%92%8Cnotify%E6%96%B9%E6%B3%95%E8%A6%81%E5%9C%A8%E5%90%8C%E6%AD%A5%E5%9D%97%E4%B8%AD%E8%B0%83%E7%94%A8%EF%BC%9F-star-star-star-three"><span class="toc-number">30.</span> <span class="toc-text">30. 为什么wait和notify方法要在同步块中调用？:star::star::star::three:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#31-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9C%A8%E5%BE%AA%E7%8E%AF%E4%B8%AD%E6%A3%80%E6%9F%A5%E7%AD%89%E5%BE%85%E6%9D%A1%E4%BB%B6%EF%BC%9F-star-star-star-star-three"><span class="toc-number">31.</span> <span class="toc-text">31. 为什么在循环中检查等待条件？:star::star::star::star::three:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#32-Synchronized%E7%9A%84%E4%BD%9C%E7%94%A8%E4%B8%BB%E8%A6%81%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F-star-star-star-two"><span class="toc-number">32.</span> <span class="toc-text">32. Synchronized的作用主要有哪些？:star::star::star::two:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#33-Java%E5%AF%B9%E8%B1%A1%E5%A4%B4%E4%B8%8E%E9%94%81%E5%92%8C%E7%9B%91%E8%A7%86%E5%99%A8%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%9F-star-star-star-three"><span class="toc-number">33.</span> <span class="toc-text">33. Java对象头与锁和监视器的关系？:star::star::star::three:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#34-Synchronized-%E9%94%81%E4%BC%98%E5%8C%96%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F-star-star-star-three"><span class="toc-number">34.</span> <span class="toc-text">34. Synchronized 锁优化了解吗？:star::star::star::three:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#35-%E5%AF%BC%E8%87%B4%E5%B9%B6%E5%8F%91%E4%BF%AE%E6%94%B9%E7%9A%84%E5%8E%9F%E5%9B%A0%EF%BC%9F-star-star-star-four"><span class="toc-number">35.</span> <span class="toc-text">35. 导致并发修改的原因？:star::star::star::four:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#36-%E8%81%8A%E8%81%8Asynchronized%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%9F-star-star-star-star-star-three"><span class="toc-number">36.</span> <span class="toc-text">36. 聊聊synchronized关键字？:star::star::star::star::star::three:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#37-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%8F%98%E9%87%8F%E6%98%AF%E5%90%A6%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%9F-star-star-star-star-three"><span class="toc-number">37.</span> <span class="toc-text">37. 如何判断变量是否线程安全？:star::star::star::star::three:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#38-%E6%9C%89%E5%93%AA%E4%BA%9B%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E7%B1%BB-star-star-star-star-three"><span class="toc-number">38.</span> <span class="toc-text">38. 有哪些线程安全的类?:star::star::star::star::three:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#39-%E5%AF%B9%E8%B1%A1%E5%A4%B4%E7%BB%93%E6%9E%84%E4%B8%8E%E9%94%81%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F-star-star-four"><span class="toc-number">39.</span> <span class="toc-text">39. 对象头结构与锁了解吗？:star::star::four:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#40-%E5%9B%9B%E7%A7%8D%E5%86%85%E7%BD%AE%E9%94%81%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F-star-star-star-star-three"><span class="toc-number">40.</span> <span class="toc-text">40. 四种内置锁了解吗？:star::star::star::star::three:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#41-%E8%81%8A%E4%B8%80%E8%81%8A%E5%81%8F%E5%90%91%E9%94%81%EF%BC%9F-star-star-star-two"><span class="toc-number">41.</span> <span class="toc-text">41. 聊一聊偏向锁？:star::star::star::two:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#42-%E5%81%8F%E5%90%91%E9%94%81%E7%9A%84%E6%92%A4%E9%94%80%EF%BC%9F-star-star-star-four"><span class="toc-number">42.</span> <span class="toc-text">42. 偏向锁的撤销？:star::star::star::four:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#43-%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E5%8E%9F%E7%90%86-star-star-star-three"><span class="toc-number">43.</span> <span class="toc-text">43. 轻量级锁原理:star::star::star::three:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#44-synchronized%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86-%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81%E5%8E%9F%E7%90%86%EF%BC%9F-star-star-star-star-four"><span class="toc-number">44.</span> <span class="toc-text">44. synchronized的底层原理 | 重量级锁原理？:star::star::star::star::four:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#45-synchronized%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%EF%BC%9F-star-star-star-star-four"><span class="toc-number">45.</span> <span class="toc-text">45. synchronized执行过程？:star::star::star::star::four:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#46-%E9%94%81%E6%B6%88%E9%99%A4%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F-star-star-star-three"><span class="toc-number">46.</span> <span class="toc-text">46. 锁消除了解吗？:star::star::star::three:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#47-%E9%94%81%E7%B2%97%E5%8C%96%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F-star-star-star-three"><span class="toc-number">47.</span> <span class="toc-text">47. 锁粗化了解吗？:star::star::star::three:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#48-%E4%BA%86%E8%A7%A3Semaphore%E5%90%97%EF%BC%9F-star-star-star-star-three"><span class="toc-number">48.</span> <span class="toc-text">48. 了解Semaphore吗？:star::star::star::star::three:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#49-Future-%E7%B1%BB%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F-star-star-star-star-three"><span class="toc-number">49.</span> <span class="toc-text">49. Future 类有什么用？:star::star::star::star::three:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#50-%E4%BB%80%E4%B9%88%E6%98%AF%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%EF%BC%9F-star-star-star-star-two"><span class="toc-number">50.</span> <span class="toc-text">50. 什么是阻塞队列？:star::star::star::star::two:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#51-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-star-star-star-three"><span class="toc-number">51.</span> <span class="toc-text">51. 阻塞队列的实现原理是什么？:star::star::star::three:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#52-%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81%E7%9A%84%E7%90%86%E8%A7%A3%E5%8F%8A%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%8C%E6%9C%89%E5%93%AA%E4%BA%9B%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%9F-star-star-star-star-three"><span class="toc-number">52.</span> <span class="toc-text">52. 乐观锁和悲观锁的理解及如何实现，有哪些实现方式？:star::star::star::star::three:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#53-%E5%A6%82%E4%BD%95%E7%A6%81%E6%AD%A2%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%BA%8F%EF%BC%9F-star-star-star-star-four"><span class="toc-number">53.</span> <span class="toc-text">53. 如何禁止指令重排序？:star::star::star::star::four:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#54-%E5%85%AC%E5%B9%B3%E9%94%81%E4%B8%8E%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E5%8E%9F%E7%90%86%EF%BC%9F-star-star-star-star-four"><span class="toc-number">54.</span> <span class="toc-text">54. 公平锁与非公平锁的区别和原理？:star::star::star::star::four:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#55-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E5%8F%AF%E4%BB%A5%E7%94%A8-synchronized-%E4%BF%AE%E9%A5%B0%E4%B9%88%EF%BC%9F-star-star-star-two"><span class="toc-number">55.</span> <span class="toc-text">55. 构造方法可以用 synchronized 修饰么？:star::star::star::two:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#56-JDK1-6-%E4%B9%8B%E5%90%8E%E7%9A%84-synchronized-%E5%BA%95%E5%B1%82%E5%81%9A%E4%BA%86%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8C%96%EF%BC%9F-star-star-star-star-three"><span class="toc-number">56.</span> <span class="toc-text">56. JDK1.6 之后的 synchronized 底层做了哪些优化？:star::star::star::star::three:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#57-%E5%8F%AF%E4%B8%AD%E6%96%AD%E9%94%81%E5%92%8C%E4%B8%8D%E5%8F%AF%E4%B8%AD%E6%96%AD%E9%94%81%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F-star-star-star-star-three"><span class="toc-number">57.</span> <span class="toc-text">57. 可中断锁和不可中断锁有什么区别？:star::star::star::star::three:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#58-%E7%BA%BF%E7%A8%8B%E6%8C%81%E6%9C%89%E8%AF%BB%E9%94%81%E8%BF%98%E8%83%BD%E8%8E%B7%E5%8F%96%E5%86%99%E9%94%81%E5%90%97%EF%BC%9F-star-star-star-four"><span class="toc-number">58.</span> <span class="toc-text">58. 线程持有读锁还能获取写锁吗？:star::star::star::four:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#59-Thread%E7%B1%BB%E4%B8%AD%E7%9A%84yield%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F-star-star-star-three"><span class="toc-number">59.</span> <span class="toc-text">59. Thread类中的yield方法有什么作用？:star::star::star::three:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#60-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%9C%80%E8%A6%81%E4%BF%9D%E8%AF%81%E5%87%A0%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81%EF%BC%9F-star-star-star-three"><span class="toc-number">60.</span> <span class="toc-text">60. 线程安全需要保证几个基本特征？:star::star::star::three:</span></a></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url('https://source.fomal.cc/img/default_cover_14.webp')"><div id="footer-wrap"><div class="copyright">&copy;2023  <i id="heartbeat" class="fa fas fa-heartbeat"></i> 墨凌</div><div class="footer_custom_text">你好, 欢迎来到我的博客!</div></div><link rel="stylesheet" href="https://fastly.jsdelivr.net/gh/HCLonely/images@master/others/heartbeat.min.css"></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><a class="icon-V hidden" onclick="switchNightMode()" title="浅色和深色模式转换"><svg width="25" height="25" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon"></use></svg></a><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div><script src="https://cdnjs.cloudflare.com/ajax/libs/algoliasearch/4.20.0/algoliasearch-lite.umd.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/instantsearch.js/4.57.0/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="fa-solid fa-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="fa-solid fa-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="fa-solid fa-arrow-rotate-right"></i></div><div class="rightMenu-item" id="menu-home"><i class="fa-solid fa-house"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" href="/archives/"><i class="fa-solid fa-archive"></i><span>文章归档</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="fa-solid fa-folder-open"></i><span>文章分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="fa-solid fa-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuNormal"><a class="rightMenu-item menu-link" id="menu-radompage" href="/random/index.html"><i class="fa-solid fa-shoe-prints"></i><span>随便逛逛</span></a><div class="rightMenu-item" id="menu-translate"><i class="fa-solid fa-earth-asia"></i><span>繁简切换</span></div><div class="rightMenu-item" id="menu-darkmode"><i class="fa-solid fa-moon"></i><span>切换模式</span></div></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.24/fancybox/fancybox.umd.min.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/instant.page/5.1.0/instantpage.min.js" type="module"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/node-snackbar/0.1.16/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (true){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="https://cdn.staticfile.org/algoliasearch/4.14.3/algoliasearch-lite.umd.min.js"></script><script src="https://cdn.staticfile.org/instantsearch.js/4.49.2/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script><div class="js-pjax"></div><script defer src="https://npm.elemecdn.com/jquery@latest/dist/jquery.min.js"></script><div class="aplayer no-destroy" data-id="7427714271" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="random" data-lrctype="1" data-preload="none" data-autoplay="true" muted></div><script src="https://cdn.staticfile.org/jquery/3.6.3/jquery.min.js"></script><script async src="https://cdn1.tianli0.top/npm/vue@2.6.14/dist/vue.min.js"></script><script async src="https://cdn1.tianli0.top/npm/element-ui@2.15.6/lib/index.js"></script><script async src="https://cdn.bootcdn.net/ajax/libs/clipboard.js/2.0.11/clipboard.min.js"></script><script defer type="text/javascript" src="https://cdn1.tianli0.top/npm/sweetalert2@8.19.0/dist/sweetalert2.all.js"></script><script async src="//npm.elemecdn.com/pace-js@1.2.4/pace.min.js"></script><script defer src="https://cdn1.tianli0.top/gh/nextapps-de/winbox/dist/winbox.bundle.min.js"></script><script async src="//at.alicdn.com/t/c/font_3586335_hsivh70x0fm.js"></script><script async src="//at.alicdn.com/t/c/font_3636804_gr02jmjr3y9.js"></script><script async src="//at.alicdn.com/t/c/font_3612150_kfv55xn3u2g.js"></script><script async src="https://cdn.wpon.cn/2022-sucai/Gold-ingot.js"></script><canvas id="universe"></canvas><script defer data-pjax src="/js/rightMenu.js"></script><script async src="/js/diytitle.js"></script><script async src="/js/grayscale.js"></script><script async src="/js/cursor.js"></script><script async src="/js/universe.js"></script><script src="/js/sun_moon.js" async></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.3/canvas-nest.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.3/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.3/click-heart.min.js" async="async" mobile="false"></script><link rel="stylesheet" href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.js"></script><script src="https://cdn1.tianli0.top/npm/js-heo@1.0.12/metingjs/Meting.min.js"></script><script src="https://lib.baomitu.com/pjax/0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener
  btf.removeGlobalFnEvent('pjax')
  btf.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div><script src="https://cdnjs.cloudflare.com/ajax/libs/algoliasearch/4.20.0/algoliasearch-lite.umd.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/instantsearch.js/4.57.0/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script></div></div><!-- hexo injector body_end start --><script data-pjax>
    function butterfly_categories_card_injector_config(){
      var parent_div_git = document.getElementById('recent-posts');
      var item_html = '<style>li.categoryBar-list-item{width:32.3%;}.categoryBar-list{max-height: 190px;overflow:auto;}.categoryBar-list::-webkit-scrollbar{width:0!important}@media screen and (max-width: 650px){.categoryBar-list{max-height: 160px;}}</style><div class="recent-post-item" style="height:auto;width:100%;padding:0px;"><div id="categoryBar"><ul class="categoryBar-list"></ul></div></div>';
      console.log('已挂载butterfly_categories_card')
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      }
    if( document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    butterfly_categories_card_injector_config()
    }
  </script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '2s');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '30');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '2s');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '30');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script></div><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js"></script><script data-pjax>
  function butterfly_clock_anzhiyu_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock_anzhiyu')
    if(parent_div_git) {
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var qweather_key = '68cca326e7b348b69328ea977b6186fe# 你的key';
  var gaud_map_key = 'ba1713bd268fa5e98ff6fa04501dc306# 你的key';
  var baidu_ak_key = 'undefined';
  var flag = 0;
  var clock_rectangle = '112.982279,28.19409';
  var clock_default_rectangle_enable = 'false';

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_anzhiyu_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_anzhiyu_injector_config();
  }
  </script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script data-pjax src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.js"></script><script data-pjax src="https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.js"></script><script data-pjax>
  function gitcalendar_injector_config(){
      var parent_div_git = document.getElementById('recent-posts');
      var item_html = '<div class="recent-post-item" id="gitcalendarBar" style="width:100%;height:auto;padding:10px;"><style>#git_container{min-height: 280px}@media screen and (max-width:650px) {#git_container{min-height: 0px}}</style><div id="git_loading" style="width:10%;height:100%;margin:0 auto;display: block;"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animatetransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animatetransform></path></svg><style>#git_container{display: none;}</style></div><div id="git_container"></div></div>';
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      console.log('已挂载gitcalendar')
      }

    if( document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
        gitcalendar_injector_config()
        GitCalendarInit("https://github-calendar-api-amber.vercel.app/api?mo0ling",['#d9e0df', '#c6e0dc', '#a8dcd4', '#9adcd2', '#89ded1', '#77e0d0', '#5fdecb', '#47dcc6', '#39dcc3', '#1fdabe', '#00dab9'],'mo0ling')
    }
  </script><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><!-- hexo injector body_end end --></body></html>